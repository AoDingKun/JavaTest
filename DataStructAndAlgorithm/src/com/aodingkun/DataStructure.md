 
---
# *数据结构概念*

##概念与术语
 - 数据 Data
 - 数据元素 Data Element
 - 数据项 Data Item
 - 数据对象 Data Object
 - 结构 Structure
##数据结构的三要素
 
   > 数据结构是指数据元素之间的关系，时复杂数据的一种组织方式。  
   研究数据结构主要从3方面入手，这3方面成为数据结构的三要素：                
      1.数据的逻辑结构  
      2.数据存储结构  
      3.数据操作（算法）  
      
### 1.数据的逻辑结构    
   >数据的逻辑关系是指客观上数据对象之间具有的关系，这往往与具体应用需求相关。
        一个数据结构（逻辑结构）两个要素
            1.数据元素的集合
            2.要素关系的集合    
   + 集合结构    
       数据元素除去"同属于一个集合"之外，无其他关系                   
   + 线性结构     
      数据可以按照某种规则排列成线性表的形式。                                       
   + 树型结构     
      数据之间呈现倒立的树型结构，每个元素都有一个双亲，有0个或多个孩子。
      元素之间呈现一对多的关系。              
   + 网状结构   
      元素与元素之间可能有多个相邻的数据元素。
      数据元素之间呈现一种多对多的关系。
 
### 2.数据的存储结构    
   >数据的存储几个是指一批数据在计算机存储器中的存储位置和存储方式，其所研究的是数据的逻辑结构在计算机中的实现方法。  
    包括逻辑数据结构中数据元素的存储及数据元素之间关系存储。  
    存储结构的基本要求：存储结构必须能够反映数据元素本身之间及数据元素之间的逻辑关系。          
   + 顺序存储结构     
     将相邻的元素存储在物理位置相邻的存储单元中，由此得到的存储表示称为顺序存储结构。
     对于逻辑上的线性结构，采用顺序存储方式则为顺序表。          
   + 链式存储结构
     对数据元素在存储器中存放位置不做特殊要求，数据元素在存储器中可以随机存放。
     为了保持数据元素之间的逻辑关系，使用“指针”将每个数据元素联系起来。     
   + 索引存储
   
   + 散列存储 
      
### 3.数据的操作    
   > 作用于数据结构上的算法=数据结构的操作。不同的数据结构其算法和操作不同。  
   
   eg：查找、更新、插入、删除      

## 抽象数据类型
- ### 数据类型 Data Type

    数据类型可以分为两类：原子类型、结构类型。
        原子类型的值不可分解 
            eg： 整型int 字符型char 浮点型float 双精度型double 等基本类型
        结构类型的值由若干成分按某种结构组成，可分解

- ### 抽象数据类型 Abastract Data Type     
    + 抽象数据的概念
        
        >抽象数据类型是指一个数据结构以及定义在该结构上的一组操作。  
        抽象的意义在于数据类型的数学抽象性        
        * 抽象数据类型的特点
            
            1.由基本数据类型组成
            
            2.反映了数据的逻辑结构以及其在逻辑结构上定义的操作。
            
            3.一种抽象操作，独立于具体实现，抽象数据类型本身间数据和操作封装以实现信息隐蔽。
    
    + 抽象数据类型的描述方法
    
        * 抽象数据类型可以用三元组（D,S,P)表示，
        
            D 数据对象 S是D上的关系集，P是对D的基本操作
        
        * ADT抽象数据类型名
           {
             
           }          

---

# 1 集合结构

# 2 线性（表）结构 Linear List
> n个相同数据类型相同的元素的有限序列  
 线性结构是一种常见的逻辑结构，线性结构也称为线性表  
 线性表的主要存储结构：顺序存储和链式存储
## 2.1 顺序表
 > 把线性表的元素按照逻辑顺序一次存放在一组地址连续的存储单元，用这种顺序存储方法存储的线性表称为顺序表
   + 基本概念 
      - 特点：      
        * 只存储数据，不存储地址信息  
        * 内存中分配连续的空间        
      - 优点：      
        * 节省存储空间          
        * 索引查找效率高        
      - 缺点：
        * 插入和删除操作都需要移动元素
        * 必须提前分配固定数量的空间，如存储元素过少，会导致空闲浪费
      -复杂度
        * 时间复杂度        
                            
                    T(n)=(n-1)/2                
        * 空间复杂度
                
                t=
        
   + 顺序表其它         
### 2.1.1 数组

### 2.1.2 Vector

### 2.1.3 ArrayList

    
    
## 2.2 链式表 Linked List
 > 链表是线性表一组重要的存储方式  
   * 基本概念
   * 其他
### * 单链表    
### * 循环链表
 * 约瑟夫问题
   
 * 单向环形链表
     
### * 双向链表
         
## 顺序表和链表的比较
 + 顺序表的优缺点
   1. 方法简单，各种高级语言都有数组，实现简单
   2. 无须为表示节点间的逻辑关系而增加额外的存储开销
   3. 顺序表具有按元素序号随机访问的特点
   4. 顺序序表中进行插入、删除操作时，平均移动大约表中一半的元素，因此对 n 较大的顺序表效率低。
   5. 需要预先分配足够大的存储空间，若预先估计过大，则可能会导致顺序表后部大量闲置；若预先分配过小，则又会造成溢出。
 + 链表的优缺点与顺序表基本相反  
   1. 链表的大小是动态的，随着数据的插入和删除而动态改变长度
   2. 链表的插入、删除非常高校，对于需要经常哈如、删除数据元素的应用，非常适合采用链表
--
## 2.3 特殊的线性结构
    数组、链表、树 主要用于大规模数据的组织，常用于显示数据的存储等数据管理。这些数据结构便于进行数据
        插入
        删除
        查找
        排序
    栈、队列的逻辑结构与线性表相同，其特点在于运算收到了限制：
        栈：先进后厨
        队列：先进先出
    故称之为受限制的线性表。
    从某种意义上来说，栈、队列是比数组、链表更为抽象的数据结构。
    既可以用数组实现栈和队列，也可以用链表来实现。
### 2.3.1 栈 Stack 
    定义 ：
        栈（Stack）是一个线性表，先进后出（First In Last Out：FILO）或后进先出（LIFO）
            其插入（也称为添加）和删除操作都在表的同一端进行。
            其中插入、删除元素的一端被称为栈顶（top），另一端被称为栈底（bottom）。
        不含元素的空表称为空栈
 - 基本介绍    
    + 先进后出FILO的有序列表  
    + 栈的限制性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表  
    + 变化的一端；栈底Bottom：固定的一端   
 1. 基本栈     
    + 插入和删除操作在表的同一端进行。栈顶 FILO/LIFO
    + 入栈            
      > top++；  
      stack [top]=data;
    + 出栈
      > int value=stack[top];  
      top--;  
      return value          
 2. 链栈： 栈的链表实现
    - 使用链表来标识堆栈，必须确定链表的哪一端为Top。
    - 如果链表的前端为栈顶Top，那么可以利链表操作addFront/removeFront来实现堆栈元素插入和删除
    - 时间复杂性均为O（1）
    - 继承与聚合
        * 继承方式实现链栈
        
        * 聚合方式实现链栈     
 3. 顺序栈：利用数组实现的栈 T[] data;
    - 1
    - 2    
 - 应用场景     
    1. 子程序的调用  
    2. 处理递归Recursion调用 回溯
        - 概念
            1. 递归就是方法自己调用自己，每次调用时传入不同的变量，
            2. 递归有助于解决复杂问题，同时让代码更加整洁
        - 递归调用机制
            1. 打印问题
            2. 阶乘问题
        - 递归遵守的重要规则
        
            1. 执行方法时，就创建一个新的受保护的独立空间（栈空间）
            2. 方法的局部变量时独立的，不会相互影响比如n变量
            3. 如果方法中使用引用类型变量（数组），就会共享该引用类型数据
            4. 递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError
            5. 当一个方法执行完毕，或者遇到return，就会返回。遵守谁调用，就将结构返回给谁，同时当方法执行完毕或返回时，该方法也就执行完毕
        - 递归解决问题
            1. 数学问题
                * 打印问题
                * 阶乘问题
                * 8皇后问题
                * 迷宫问题
                * 球和篮子
            2. 算法应用
                * 快排
                * 归并排序
                * 二分查找
                * 分治算法
            3. 用栈解决的问题
            
        - 排序算法的介绍
            - 内部排序
                - 插入排序
                    + 最直接插入排序
                    + 希尔排序
                - 选择排序
                    + 简单选择排序
                    + 堆排序
                - 交换排序
                    + 冒泡排序
                    + 快速排序
                - 归并排序
                - 基数排序
            - 外部排序
        -
    3. 表达式的转换 [中缀表达式转后缀表达式] 和求值[前缀 中缀 后缀（逆波兰）表达式] 
        + 前缀表达式：波兰表达式
            - +×ab×-c/d
            - 前缀表达式的运算符位于操作数之前
            - 从右至左扫描表达式，遇到数字时，将数字压入堆栈；
            遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算，并将结果入栈；
            重复上诉过程直到表达式的最左端，最后的运算结果即为表达式结果。
        + 中缀表达式
            - 常见的运算表达式，但对计算机不好操作
            - a×b+（c-d/e）×f
        + 后缀表达式：逆波兰表达式
            - ab×cde/-f×+
            - 后缀表达式与前缀表达式相似，只是运算符位于操作数之后
        + 后缀表达式的求值 suffixExpression
            - 常规表达式：a×b+（c-d/e）×f
            - 后缀式：ab×cde/-f×+
            - 步骤分析
                1. 运算符在式中出现的顺序恰为表达式的运算顺序；
                2. 每个运算符与在它之前且紧靠它的两个操作数构成一个最小表达式
                3. 后缀表达式求值过程是以操作符为中心的
        + 中缀表达式转换成后缀表达式
            - x
            -步骤
                1. 为操作符设一个栈OPSS
                2. 预设栈OPS的栈顶为"#" 
                3. token=gettoken(),标识从常规表达式读取的当前记号           
    4. 二叉树的遍历
        +
        + 
    5. 图形的深度优先（deepth-first）搜索法
        +
        + 
 - 
   

   
### 2.3.2 队列 Queue
    “先进先出”（FIFO，First In First Out）的数据结构，
    即插入数据在表一端进行，而删除数据在表的另一端进行，将这种数据结构称为队或队列，
    把允许插入数据的一端称为队尾（rear），
    把允许删除数据的一端称为队首（front）
 
 1. 基本队列
    
 2. 链式队列
    
 3. 顺序队列
    
 4. 循环队列
    
### 2.3.3 特殊矩阵
 
 1.二维数组
     
 2.对称矩阵和三角矩阵
     
 3.对角矩阵
     
 4.稀疏矩阵 Sparse Martrix
     
### 2.3.4 广义表 Generalized Lists
 
 
 
    

  
---
# 3 树结构
- ##树
- ##二叉树
- ##哈夫曼树

# 4 网状结构

---

## 线性查找算法
### 查找的基本概念
 + 查找结构
    - 查找
    - 插入
    - 删除
    - 更新
 + 查找结构分类
    - 逻辑结构分类
        * 线性查找结构
            线性查找结构主要有
                - 顺序表 
                - 链表 
                - 散列表
        * 树形查找结构
            - 二叉查找树
            - 多叉查找树
    - 查找结构内容分类
        + 静态查找结构
        + 动态查找结构
 + 平均查找长度ASL

### 线性查找表
 1. 顺序查找
    + 概念
        对数组有序无序没有要求
 2. 二分查找
    + 概念
        在有序数组中进行二分查找
    + 思路
        1. 首先确定数组中间值的下标
        2. 然后让需要查找的数findValue 与 mid 比较
            - if findvalue>mid 则在mid右边 因此需要递归向右查找
            - if findvalue<mid 则在左边 因此需要递归向左查询
            - if findvalue=mid 说明找到 就返回
            
            // 什么时候结束递归
            1. 找到就结束递归
            2. 递归ALL 集合 仍然没有找到findValue 业务需要结束递归。  
                if left> right 需要退出
        3.
    + 方法
        - 递归
        - 非递归
    
 3. 分块查找
 4. 插值查找
    + 概念  
            将二分查找中的mid索引 low标识左边索引left high表示右边索引righ key就是findValue
    + 原理  
              
                        mid=(low+hight)/2=low+1/2（hight-low)
                        ||
                        \/
                        mid=low+$\frac{key-a[low]}{a[high]-a[low]}$ *(high-low)
              插值索引  int mid=low+(high-low)*(key-arr[low])/(arr[high]-arr[low]) 
              int mid=left+(right-left)*(findval-arr[left])/(arr[right]-arr[left])
    +注意事项  
        1. 对于数据量比较大的，关键字分布比较均匀的查找表来说 采用插值查找 速度比较快
        2. 关键字分布不均匀 该方法不一定比折半查找要好
 5. 斐波那契查找(黄金分割点查找)
    + 斐波那契数列
    + 原理
        仅仅改变了中间节点mid的位置，mid不再是中间或插值得到，而是黄金分割点附近。  
            
            mid=low+F(k-1)-1      
    + 对 F(k-1)-1 理解
        whie(n>fib(k)-1)
        k++;
    + 

#### 哈希查找

#### 哈希映射

#### 串匹配

### 树型查找

---
## 排序算法 Sort Algorithm
> 度量一个程序算法执行事件的两种方法
 >  - 事后统计法
 
 >       此方法需要在同一台计算机的相同状态下运行，才能比较那个算法运行速度更快
 >  - 事前统计法       
 >          通过风格某个算法的事件复杂度来判断何种算法更优
### 算法的时间复杂度
#### 1. 时间频度
    
    一个算法耗费的时间与算法中语句的执行次数成正比，哪个算法中语句执行次数多，其耗费的时间就多。
    一个算法中的语句执行次数称为语句的频度或时间频度
        T(n)
       忽略常数项
       忽略系数
       忽略低次项+         
#### 2. 时间复杂度
- 算法中基本操作语句的重复执行次数是问题规模n的某个函数 用f(n)表示，若某个辅助函数f()n 使得n趋近于无穷大时，T(n)/f(n)的极限值不等于0阐述，则称f(n)是T(n)的同数量级函数
    T(n)=O(f(n)) 时间复杂度
- T(n)不同 当时间复杂度可能相同
- 常见的时间复杂度
    + 常数阶   O(1)
    + 对数阶   O(log2n)
    
            int i=1;
            while(i<n)
            {
                i=i*2;
            }    
        
    + 线性阶   O(n)
    
        for循环
                        
            for(int i=1;i<n;++i)
                {
                    j=i;
                    j++
                }  
    + 线性对数阶     O(nlogN)
        
            for(int m=1;m<n;m++){
                i=1;
                whie(i<n)
                {
                    i=i*2
                }    
            }  
    + 平方阶   O(n^2)
            
            for(x=1;i<=n;x++)
            {
                for(i=1;i<=n;i++)
                {
                    j=i;
                    j++;
                }
            }        
    + 立方阶
    + K次方阶
    + 指数阶    
#### 3. 平均时间复杂度和最坏时间复杂度
1.  平均时间复杂度 所有可能的输入实例均以等概率出现的情况下，该算法运行的时间
2. 最坏时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长
### 算法的空间复杂度
#### 基本介绍
- 定义：该算法所耗费的存储空间
- 算法空间复杂度是对一个算法在运行过程中临时占用存储空间大小的零度

    
### 1. 内部排序
>使用内存进行排序
  将需要处理的数据都加载到内部存储器中进行排序
- 插入排序 Insertion Sorting   
   插入排序属于内部排序法，是对欲排序的元素以插入的方式寻找该元素的适当位置，以达到排序的目的。
    + 直接插入排序 Insert Sorting
        + 基本思想  
            >   其基本思想是将线性表看成有序和无序两个部分，            
                有序子表是a[0：i-1]，无序子表是a[i：n-1]，
             排序过程是每次从无序子表中取出一个元素将其插入到有序子表的正确位置，
             使有序子表保持有序并逐渐增大，直到所有记录都插入有序区为止。
        + 代码  
            [插入排序](file:///DataStructure\sort\InsertSort.java)
    + 希尔排序 Shell Sorting
        > 希尔排序（Shell Sort）是插入排序的一种，也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。  
            希尔排序是不稳定排序算法，该方法因David.L.Russell于1959年提出而得名。
        - 基本思想  
            希尔排序 是把记录按下标的一定增量分组，对魅族使用世界插入排序算法；随着增量组件减少，每组包含的关键词越来越多，当增量减至1时，整个文件被分成一组，算法便终止。
        
   
- 选择排序 Select Sorting
    + 简单选择排序
        - 思想
        
           其基本思想仍然是将线性表看成有序和无序两个部分，
           有序子表是a[0：i-1]，无序子表是a[i：n-1]。
           
           排序过程中每次从无序子表中选出最小的一个元素，将其添加到有序子表的末尾，
           有序子表保持有序并且长度增加1，无序子表长度减小1，重复这个过程直到无序子表为空。 
        - 
    + 堆排序
- 交换排序
    + 冒泡排序 Bubble Sorting
        - 基本思想              
            通过对待排序序列从前向后，一次比较相邻元素的值，若发现逆序则交换，使值较大的元素组件从前移向后部。
        - 图解 
    + 快速排序
        > 快速排序又称为分区交换排序，是目前已知的实测平均速度最快的一种排序方法，它是对冒泡排序方法的一种改进。
        - 基本思想  
            通过一趟划分将要排序序列分割成独立的三个部分，即左部、基准值、右部。其中左部的所有数据都比基准值小，右边的所有数据都比基准值大。然后再按此方法分别对左部和右部进行划分。整个排序过程可以递归进行。
        - 图解
        
- 归并排序 Merge Sorting
    > 归并排序是将两个有序序列合并成为一个有序序列。因此将两个有序子序列合并成一个有序序列是归并排序的基础算法。
    + 基本思想  
        采用基点的分治[divide-and-conquer]策略   
         + 分：将问题分成一些小问题然后递归求解，  
         + 治：将分的阶段得到的各档案“修补”在一起
    + 

- 基数排序 Radix Sort
    + 基本介绍
        - 分配式排序 bucket sort ：通过键值的各个位的值，将要排序的元素分配到某些“桶”中达到排序的作用
        - 稳定性排序： 基数排序式效率高的稳定性排序法
        - 基数排序是桶排序的扩展 
    + 基本思想  
        将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，一次进行一次排序。  
        这样从最低位排序一直到最高位排序完成以后，数列就编程一个有序序列。
    +


### 2. 外部排序
    使用内存和外存结合，
    数据流过大 无法全部加载到内存中，需要借助外部存储进行排序
